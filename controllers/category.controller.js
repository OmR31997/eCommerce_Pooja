import { Category } from '../models/category.model.js';
import { DeleteLocalFile, GenerateSlug, Pagination, ValidateFileSize, ValidateImageFileType } from '../utils/fileHelper.js';
import { ToDeleteFromCloudStorage, ToSaveCloudStorage } from '../services/cloudUpload.service.js';

/* **create_product_category logic here** */
export const create_product_category = async (req, res) => {
    try {
        const { name, slug, description, parent } = req.body;
        const file = req.file;

        // Top-Level and Subcatecory Validation
        const isSubCategory = req.query.sub === 'true';

        if (isSubCategory && !parent) {
            return res.status(400).json({
                error: `Parent category 'id' value is required for 'parent' field`,
                success: false,
            });
        }
        else if (!isSubCategory && parent) {
            return res.status(400).json({
                error: `Top-level categories must have 'parent' that default set null so please not include it`,
                success: false,
            })
        }

        // Prevent Manual Slug Update
        if (slug) {
            return res.status(400).json({
                error: `Please do not include 'slug' field — it is auto-generated by the system.`,
                success: false,
            });
        }

        // Fetch Category
        if (!parent) {
            const parentCategory = await Category.findOne({ name });

            if (parentCategory) {
                return res.status(400).json({
                    error: `Parent category name '${name}' already exist`,
                    success: false,
                });
            }
        } else {
            const existCategory = await Category.findById(parent);

            if (!existCategory) {
                return res.status(400).json({
                    error: `Category not found for ID: ${parent}`,
                    success: false,
                });
            }
        }

        const generatedSlug = await GenerateSlug(name);

        // Assigning some fields into the category
        const categoryData = {
            name,
            slug: generatedSlug,
            description,
            parent: parent ?? null,
        }

        // Manage DB, Cloud/Local Storage If File Uploading 
        if (file) {
            if (!ValidateImageFileType(file.mimetype)) {
                DeleteLocalFile(file.path);
                return res.status(400).json({
                    error: 'Invalid file type. Only images allowed.',
                    success: false,
                });
            }

            if (!ValidateFileSize(file.size, 1)) {
                DeleteLocalFile(file.path);
                return res.status(400).json({
                    error: 'File size exceeds 2MB limit',
                    success: false,
                });
            }

            const categoryFileName = `${generatedSlug.substring(0, 3).toUpperCase()}_${file.filename}`;

            // Upload Image Into The Local/Cloud Storage
            if (process.env.NODE_ENV !== 'development') {
                const { secure_url } = await ToSaveCloudStorage(file.path, 'eCommerce/Categories', categoryFileName);
                categoryData.imageUrl = secure_url;
            }
            else {
                categoryData.imageUrl = file.path;
            }
        }

        // Careate new category record into the db.collection
        const responseCategory = await Category.create(categoryData);

        return res.status(201).json({
            message: 'Category created successfully',
            data: responseCategory._doc,
            success: true,
        });

    } catch (error) {
        if (error.name === 'ValidationError') {
            const errors = {};

            Object.keys(error.errors).forEach(key => {
                errors[key] = error.errors[key].message
            });

            return res.status(400).json({
                errors,
                message: 'Validation failed',
                success: false,
            });
        }

        return res.status(500).json({
            error: error.message,
            message: 'Internal Server Error',
            success: false,
        });
    }
}

/* **update_category logic here** */
export const update_category = async (req, res) => {
    try {
        const categoryId = req.params.id;
        const { slug, parent, ...rest } = req.body;
        const file = req.file;

        // Fetch Category
        const category = await Category.findById(categoryId);

        if (!category) {
            return res.status(404).json({
                error: `Category not found for ID: '${categoryId}'`,
                success: false,
            });
        }

        if (!category.parent && parent) {
            return res.status(400).json({
                error: 'Cannot update parent to top-level category',
                success: false,
            });
        }

        // Prevent Manual Slug Update
        if (slug) {
            return res.status(400).json({
                error: `Please do not include 'slug' field — it is auto-generated by the system.`,
                success: false,
            });
        }

        if (Object.keys(rest).length === 0 && !file) {
            return res.status(400).json({
                error: 'No field found for update',
                success: false,
            });
        }

        // Manage DB, Cloud/Local Storage If File Uploading 
        if (file) {
            if (!ValidateImageFileType(file.mimetype)) {
                DeleteLocalFile(file.path);
                return res.status(400).json({
                    error: 'Invalid file type. Only images allowed.',
                    success: false,
                });
            }

            if (!ValidateFileSize(file.size, 1)) {
                DeleteLocalFile(file.path);
                return res.status(400).json({
                    error: 'File size exceeds 2MB limit',
                    success: false,
                });
            }

            const categoryFileName = `${category.slug.substring(0, 3).toUpperCase()}_${file.filename}`;

            // Upload Image Into The Local/Cloud Storage
            if (process.env.NODE_ENV !== 'development') {
                const { secure_url } = await ToSaveCloudStorage(file.path, 'eCommerce/Categories', categoryFileName);
                rest.imageUrl = secure_url;
            }
            else {
                rest.imageUrl = file.path;
            }

            // Delete Old file from the Local/Cloud Storage
            if (category.imageUrl) {
                if (process.env.NODE_ENV !== 'development')
                    await ToDeleteFromCloudStorage('eCommerce/Categories', category.imageUrl);
                else
                    DeleteLocalFile(category.imageUrl);
            }
        }

        // Update slug field of category
        if (rest.name && rest.name !== category.name) {
            const existCategory = await Category.findOne({ name: rest.name });
            if (existCategory) {
                return res.status(404).json({
                    error: `Another category already exists with name '${rest.name}'`,
                    success: false,
                })
            }

            category.slug = await GenerateSlug(rest.name);
        }

        // Update fields of category instead of slug
        if (Object.keys(rest).length > 0) {
            Object.keys(rest).forEach(key => {
                category[key] = rest[key];
            });
        }

        // Apply updating into the db.collection
        const updateResponse = await category.save();
        return res.status(200).json({
            message: 'Category updated successdully',
            data: updateResponse,
            success: true
        });
    } catch (error) {
        console.error('Error updating category:', error);
        return res.status(500).json({
            error: 'Internal server error',
            success: false,
        });
    }
}

/* **view_categories logic here** */
export const view_categories = async (req, res) => {
    try {
        const { 
            page = 1, 
            limit = 10, 
            offset = 0, 
            status = 'active', 
            parent, 
            sortBy='-createdAt', 
            order='-1'} = req.query;

        const parsedPage = parseInt(page);
        const parsedLimit = parseInt(limit);

        // Build Query
        const query = {};

        // Handle Status
        if (status) query.status = status;

        query.parent = (parent === 'null' || parent === undefined) ? null : parent;
        
        // Count total records
        const total = await Category.countDocuments(query);
        const { skip, nextUrl, prevUrl, totalPages, currentPage } = Pagination(
            parsedPage,
            parsedLimit,
            offset,
            total,
            status,
            `${req.protocol}://${req.get('host')}${req.baseUrl}${req.path}`);

        const sortField = ['name', 'slug', 'createdAt'].includes(sortBy) ? sortBy : 'createdAt';
        const sortOption = {[sortField]: Number(order)};
        
        const categories = await Category.find(query)
            .skip(skip)
            .limit(parsedLimit)
            .sort(sortOption)
            .populate({
                path: 'subcategories',
                populate: {
                    path: 'subcategories'
                }
            });

            console.log(categories)
        if (categories.length === 0) {
            return res.status(404).json({
                error: 'Category not found',
                success: false,
            });
        }

        return res.status(200).json({
            message: 'Categories fetched successfully.',
            data: categories,
            pagination: {
                count: total,
                prevUrl,
                nextUrl,
                currentPage,
                totalPages,
                success: true,
            }
        });

    } catch (error) {
        return res.status(500).json({
            error: error.message,
            message: 'Internal Server Error',
            success: false,
        });
    }
}

/* **view_category_byId logic here** */
export const view_category_byId = async (req, res) => {
    try {
        const categoryId = req.params.id;
        const category = await Category.findById(categoryId);

        if (!category) {
            return res.status(400).json({
                error: `Category not found for ID: '${categoryId}'`,
                success: false,
            });
        }

        return res.status(200).json({
            data: category,
            success: true,
        });

    } catch (error) {
        return res.status(500).json({
            error: error.message,
            message: 'Internal Server Error',
            success: false,
        });
    }
}

/* **view_category_bySlug logic here** */
export const view_category_bySlug = async (req, res) => {
    try {
        const categorySlug = req.params.slug;

        const category = await Category.findOne({ slug: categorySlug });

        if (!category) {
            return res.status(400).json({
                error: `Category not found for slug: '${categorySlug}'`,
                success: false,
            });
        }

        return res.status(200).json({
            data: category,
            success: true,
        });

    } catch (error) {
        return res.status(500).json({
            error: error.message,
            message: 'Internal Server Error',
            success: false,
        });
    }
}


export const search_category = async (req, res) => {
  try {
    const {
      find,
      page = 1,
      limit = 10,
      sortBy = 'createdAt',
      order = -1
    } = req.query;

    if (!find || find.trim() === '') {
      return res.status(400).json({
        success: false,
        message: "Please provide a search query in '?find=' parameter."
      });
    }

    const parsedPage = parseInt(page);
    const parsedLimit = parseInt(limit);

    // 1️⃣ Try text search first
    let query = { $text: { $search: find } };
    let projection = { score: { $meta: "textScore" } };
    let sortOption = { score: { $meta: "textScore" } };

    let total = await Category.countDocuments(query);
    let { skip, nextUrl, prevUrl, totalPages, currentPage } = Pagination(
      parsedPage,
      parsedLimit,
      0,
      total,
      null,
      `${req.protocol}://${req.get('host')}${req.baseUrl}${req.path}?find=${find}`
    );

    let categories = await Category.find(query, projection)
      .skip(skip)
      .limit(parsedLimit)
      .sort(sortOption);

    // 2️⃣ Fallback to regex if text search finds nothing
    if (categories.length === 0) {
      query = {
        $or: [
          { name: { $regex: find, $options: "i" } },
          { description: { $regex: find, $options: "i" } }
        ]
      };

      // Sorting for regex fallback
      const allowedSorts = ['name', 'slug', 'createdAt'];
      const safeSortBy = allowedSorts.includes(sortBy) ? sortBy : 'createdAt';
      sortOption = { [safeSortBy]: parseInt(order) };

      total = await Category.countDocuments(query);
      const pagination = Pagination(
        parsedPage,
        parsedLimit,
        0,
        total,
        null,
        `${req.protocol}://${req.get('host')}${req.baseUrl}${req.path}?find=${find}`
      );

      categories = await Category.find(query)
        .skip(pagination.skip)
        .limit(parsedLimit)
        .sort(sortOption);

      nextUrl = pagination.nextUrl;
      prevUrl = pagination.prevUrl;
      totalPages = pagination.totalPages;
      currentPage = pagination.currentPage;
    }

    if (!categories.length) {
      return res.status(404).json({
        success: false,
        message: `No categories found matching "${find}".`
      });
    }

    return res.status(200).json({
      success: true,
      message: `Found ${categories.length} matching categories.`,
      data: categories,
      pagination: {
        count: total,
        prevUrl,
        nextUrl,
        currentPage,
        totalPages
      }
    });

  } catch (error) {
    console.error('Error in search_category:', error);
    return res.status(500).json({
      success: false,
      message: 'Internal Server Error',
      error: error.message
    });
  }
};


export const view_paginated_categories = async (req, res) => {
    try {
        const { page = 1, limit = 10, offset, status } = req.query;

        const skip = Pagination(page, limit, offset);

        const categories = await Category.find({ status })
            .skip(skip)
            .limit(parseInt(limit))
            .sort({ createdAt: -1 });

        if (categories.length === 0) {
            return res.status(404).json({
                error: 'Category not found',
                success: false,
            });
        }

        const total = await Category.countDocuments({ status });
        const currentPage = parseInt(page);
        return res.status(200).json({
            data: categories,
            success: true,
            total,
            totalPages: Math.ceil(total / limit),
            next: currentPage < totalPages ? currentPage + 1 : null,
            prev: currentPage > 1 ? currentPage - 1 : null,
            current: currentPage,
        })
    } catch (error) {
        console.error('Error in search_category:', error);
        return res.status(500).json({
            success: false,
            message: 'Internal Server Error',
            error: error.message,
        });
    }
}

/* **remove_category logic here** */
export const remove_category = async (req, res) => {
    try {
        const categoryId = req.params.id;

        const category = await Category.findOneAndDelete(categoryId);

        if (!category) {
            return res.status(404).json({
                error: `Category not found for ID: '${categoryId}'`,
                success: false,
            });
        }

        if (process.env.NODE_ENV !== 'development')
            await ToDeleteFromCloudStorage('eCommerce/Categories', category.imageUrl);
        else
            DeleteLocalFile(category.imageUrl);

        return res.status(200).json({
            message: 'Category deleted successfully',
            data: category,
            success: true,
        });
    } catch (error) {
        return res.status(500).json({
            error: error.message,
            message: 'Internal Server Error',
            success: false,
        });
    }
}

/* **clear_category logic here** */
export const clear_Category = async (req, res) => {
    try {
        const categories = await Category.find();

        if (categories.length === 0) {
            return res.status(404).json({
                error: 'No categories found to delete',
                success: false,
            });
        }

        const result = await Category.deleteMany({});

        if (result.deletedCount === 0) {
            return res.status(404).json({
                error: 'No categories found to delete',
                success: false,
            });
        }

        for (const category of categories) {
            if (process.env.NODE_ENV !== 'development')
                await ToDeleteFromCloudStorage('eCommerce/Categories', category.imageUrl);
            else
                DeleteLocalFile(category.imageUrl);
        }

        return res.status(200).json({
            message: `All categories cleared successfully (${result.deletedCount} deleted)`,
            success: true,
        });

    } catch (error) {
        return res.status(500).json({
            error: error.message,
            message: 'Internal Server Error',
            success: false,
        });
    }
}