import { Vendor } from '../models/vendor.model.js';
import { Category } from '../models/category.model.js';
import { Product } from '../models/product.model.js';
import { BuildProductQuery, DeleteLocalFile, Pagination, ValidateFileSize, ValidateImageFileType } from '../utils/fileHelper.js';

/* **create_product logic here** */
export const create_product = async (req, res) => {
    const sessionFiles = []; // Track uploaded files so we can rollback if needed

    try {
        const { sku, categorySlug, ...rest } = req.body;
        const { id: vendorId } = req.user;
        const files = req.files || [];

        if (rest?.vendorId && rest.vendorId !== vendorId) {
            return res.status(403).json({
                error: 'Vendor ID mismatch — unauthorized action',
                success: false,
            });
        }

        if (sku) {
            return res.status(400).json({
                error: `Please do not include 'sku' field — it is auto-generated by the system.`,
                success: false,
            });
        }

        if (!categorySlug) {
            return res.status(400).json({
                error: `'categorySlug' field must be required`,
                success: false,
            });
        }

        const category = await Category.findOne({ slug: categorySlug }).select('_id name');

        if (!category) {
            return res.status(404).json({
                error: 'Category not found',
                success: false,
            });
        }

        const default_sku = `SKU-${Date.now()}-${Math.floor(Math.random() * 1000)}`;

        const productData = {
            ...req.body,
            vendorId,
            categoryId: category._id,
            sku: default_sku,
        }

        let productImages = [];
        if (files && files.length > 0) {
            const errors = [];
            console.log(files);

            for (const file of files) {
                const { originalname, mimetype, size, path: filePath } = file;
                if (!ValidateImageFileType(mimetype)) {
                    errors.push(`Invalid file type: ${mimetype} with this file ${originalname}. Only jpeg, png, webp, jpg allowed.`);
                }

                if (!ValidateFileSize(size, 1)) {
                    errors.push(`Each file should be less than 1MB - ${originalname} file is too large`)
                }

                sessionFiles.push(filePath);
            }

            if (errors.length > 0) {

                sessionFiles.forEach(file => {
                    DeleteLocalFile(file);
                });

                return res.status(400).json({
                    errors,
                    success: false,
                });
            }

            for (const file of files) {
                const { path: filePath, filename } = file;

                const productFileName = `${categorySlug.substring(0, 3).toUpperCase()}_${filename}`;

                if (process.env.NODE_ENV !== 'development') {
                    const { secure_url } = await ToSaveCloudStorage(filePath, `eCommerce/${vendorId}/images`, productFileName);

                    productImages.push(secure_url); //For DB
                }
                else {
                    productImages = [...sessionFiles];  //For Local
                }
            }
        }

        productData.images = productImages;
        const responseProduct = await Product.create(productData);

        return res.status(201).json({
            message: 'Product created successfully',
            data: {
                ...responseProduct._doc,
                categoryName: category.name,
            },
            success: true,
        });

    } catch (error) {
        if (error.name === 'ValidationError') {
            const errors = {};

            Object.keys(error.errors).forEach(key => {
                errors[key] = error.errors[key].message;
            });

            return res.status(400).json({
                errors,
                message: 'Validation failed',
                success: false,
            });
        }

        return res.status(500).json({
            error: error.message,
            message: 'Internal Server Error',
            success: false,
        });
    }
}

/* **view_products logic here** */
export const view_products = async (req, res) => {
    try {
        const {
            page = 1, limit = 10, offset,
            status = 'approved',
            sortBy = 'createdAt', orderSequence = 'desc' } = req.query;

        const parsedLimit = parseInt(limit);

        // Build Query
        const filter = {};

        // Handle Status
        if (status) filter.status = status;

        // Count total records
        const total = await Product.countDocuments(filter);

        const { skip, nextUrl, prevUrl, totalPages, currentPage } = Pagination(
            parseInt(page),
            parsedLimit,
            offset,
            total,
            status,
            `${req.protocol}://${req.get('host')}${req.baseUrl}${req.path}`, filter);

        const sortField = ['name', 'price', 'createdAt'].includes(sortBy) ? sortBy : 'createdAt';
        const sortDirection = orderSequence === 'asc' ? 1 : -1;
        const sortOption = { [sortField]: sortDirection };

        const products = await Product.find(filter)
            .populate({ path: 'vendorId' })
            .populate({ path: 'categoryId' })
            .skip(skip)
            .limit(parsedLimit)
            .sort(sortOption)

        if (products.length === 0) {
            return res.status(404).json({
                error: 'Product not found',
                success: false,
            });
        }

        return res.status(200).json({
            message: 'Products fetched successfully.',
            pagination: {
                count: total,
                prevUrl,
                nextUrl,
                currentPage,
                totalPages,
                success: true,
            },
            data: products,
        });

    } catch (error) {
        return res.status(500).json({
            error: error.message,
            message: 'Internal Server Error',
            success: false,
        });
    }
}

/* **view_single_product logic here** */
export const view_single_product = async (req, res) => {
    try {
        const key = req.params.id;

        const filter = key.startsWith('SKU-') ? { sku: key } : { _id: key };
        filter.status = 'approved';

        const product = await Product.findOne(filter)
            .populate({ path: 'vendorId', select: 'shopName -_id' })
            .populate('categoryId', 'name slug -_id')
            .select('-vendorId -categoryId');

        if (!product) {
            return res.status(404).json({
                error: 'Product not found',
                success: false,
            });
        }

        return res.status(200).json({
            data: product,
            success: true,
        });

    } catch (error) {
        return res.status(500).json({
            error: error.message,
            message: 'Internal Server Error',
            success: false,
        });
    }
}

/* **view_vendor_products logic here** */
export const view_vendor_products = async (req, res) => {
    try {
        const vendorId = req.user.id;

        const products = await Product.find({ vendorId })
            .populate({ path: 'vendorId', select: 'shopName' })
            .populate('categoryId', 'name slug -_id')
            .select('-vendorId -categoryId');;

        if (products.length === 0) {
            return res.status(400).json({
                error: 'Product not found',
                success: false,
            });
        }

        return res.status(200).json({
            data: products,
            success: true,
        });

    } catch (error) {
        return res.status(500).json({
            error: error.message,
            message: 'Internal Server Error',
            success: false,
        });
    }
}

/* **view_vendor_product logic here** */
export const view_vendor_product = async (req, res) => {
    try {
        const vendorId = req.user.id;
        const productId = req.params.id;

        const products = await Product.find({ _id: productId, vendorId })
            .populate({ path: 'vendorId', select: 'shopName' })
            .populate('categoryId', 'name slug -_id')
            .select('-vendorId -categoryId');

        if (products.length === 0) {
            return res.status(400).json({
                error: 'Product not found',
                success: false,
            });
        }

        return res.status(200).json({
            data: products,
            success: true,
        });

    } catch (error) {
        return res.status(500).json({
            error: error.message,
            message: 'Internal Server Error',
            success: false,
        });
    }
}

/* **manage_product logic here** */
export const manage_product_byVendor = async (req, res) => {
    try {
        const key = req.params.id;

        const filter = key.startsWith('SKU-') ? { sku: key } : { _id: key };
        const { _id, status, sku, vendorId, rating, slug, ...rest } = req.body;
        const { id, role } = req.user;

        if (rating) {
            return res.status(400).json({
                error: `You cannot manually update 'rating' fields.`,
                success: false,
            })
        }

        const product = await Product.findOne(filter);
        if (!product) {
            return res.status(404).json({
                error: 'Product not found',
                success: false,
            });
        }


        if (role === 'vendor') {

            if (status) {
                return res.status(400).json({
                    error: `You cannot update 'status' field — please talk with admin`,
                    success: false,
                });
            }

            if (sku) {
                return res.status(400).json({
                    error: `Please do not include 'sku' field — it is auto-generated by the system.`,
                    success: false,
                });
            }

            if (slug) {
                const category = await Category.findOne({ slug });

                if (!category) {
                    return res.status(404).json({
                        error: `Category with slug '${slug}' not found`,
                        success: false,
                    });
                }

                rest.categoryId = category._id;
            }

            if (vendorId || _id) {
                return res.status(400).json({
                    error: `You cannot modify protected fields like 'vendorId' or '_id'.`,
                    success: false,
                });
            }

            if (Object.keys(rest).length === 0) {
                return res.status(400).json({
                    error: 'No valid field to update',
                    success: false,
                })
            }

            if (product.vendorId.toString() !== id) {
                return res.status(403).json({
                    error: 'You are not authorized to modify this product.',
                    success: false,
                });
            }

            Object.assign(product, rest);

            const updateProduct = await product.save();

            return res.status(200).json({
                message: 'Product updated successfully',
                data: updateProduct,
                success: true,
            });
        }
        else if (role === 'admin') {


        }
        else {
            return res.status(403).json({
                error: 'You are not authorized to perform this action.',
                success: false,
            });
        }

    } catch (error) {
        return res.status(500).json({
            error: error.message,
            message: 'Internal Server Error',
            success: false,
        });
    }
}

/* **rate_product logic here** */
export const rate_product = async (req, res) => {
    try {
        const { rating } = req.body;
        const productId = req.params.id;

        if (!rating || rating < 1 || rating > 5) {
            return res.status(400).json({
                error: `'rating' field is required and must be between 1 to 5 `,
                success: false,
            });
        }

        const product = await Product.findById(productId);

        if (!product) {
            return res.status(400).json({
                error: 'Product not found',
                success: false,
            });
        }

        const total = product.rating.totalReview;
        const avg = product.rating.average;

        const newTotal = total + 1;
        const newAvg = ((avg * total) + rating) / newTotal;

        product.rating.average = parseFloat(newAvg.toFixed(1));
        product.rating.totalReview = newTotal;

        const ratingResponse = await product.save();

        return res.status(200).json({
            message: 'Product rated successfully',
            data: ratingResponse,
            success: true,
        });

    } catch (error) {
        return res.status(500).json({
            error: error.message,
            message: 'Internal Server Error',
            success: false,
        });
    }
}

/* **product_filters logic here** */
export const product_filters = async (req, res) => {
    try {
        const {
            search, category,
            stockStatus, priceRange,
            vendor, rating,
            discount, status,
            page = 1, limit =2, offset,
            sortBy = 'createdAt', orderSequence = 'desc'
        } = req.query;

        // Build Filters 
        const filters = {
            search: search || '',
            category: category || '',
            stockStatus: stockStatus || '',
            priceRange: priceRange ? priceRange.split(',').map(Number) : undefined,
            vendorId: vendor || '',
            rating: rating ? Number(rating) : undefined,
            discount: discount ? Number(discount) : undefined,
            status: status || 'approved',
        };

        const parsedLimit = parseInt(limit);

        // Build Mongo query
        const query = BuildProductQuery(filters);

        // Count Total Docs
        const total = await Product.countDocuments(query);

        const { skip, nextUrl, prevUrl, totalPages, currentPage } = Pagination(
            parseInt(page),
            parsedLimit,
            offset,
            total,
            `${req.protocol}://${req.get('host')}${req.baseUrl}${req.path}`,
            filters,
        );

        // Sorting
        const sortField = ['name', 'price', 'createdAt'].includes(sortBy) ? sortBy : 'createdAt';
        const sortDirection = orderSequence === 'asc' ? 1 : -1;
        const sortOption = { [sortField]: sortDirection };

        const products = await Product.find(query)
            .skip(skip)
            .limit(limit)
            .sort(sortOption)
            .populate({ path: 'vendorId', select: 'name businessName' })
            .populate({ path: 'categoryId', select: 'name slug' });

        return res.status(200).json({
            message: 'Products fetched successfully',
            data: products,
            pagination: {
                count: total,
                prevUrl,
                nextUrl,
                currentPage,
                totalPages,
            },
            success: true,
        });

    } catch (error) {
        console.error('Error in product_filters:', error);
        return res.status(500).json({
            error: error.message,
            message: 'Internal Server Error',
            success: false,
        });
    }
};
